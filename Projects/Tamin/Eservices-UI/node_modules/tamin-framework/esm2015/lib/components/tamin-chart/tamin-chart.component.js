/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { TaminLazyLoadService } from '../../services/tamin-lazy-load/tamin-lazy-load.service';
import { HostListener } from '@angular/core';
export class TaminChartComponent {
    /**
     * @param {?} taminLazyLoadService
     */
    constructor(taminLazyLoadService) {
        this.taminLazyLoadService = taminLazyLoadService;
        this.defaultColors = [
            [255, 99, 132],
            [54, 162, 235],
            [255, 206, 86],
            [231, 233, 237],
            [75, 192, 192],
            [151, 187, 205],
            [220, 220, 220],
            [247, 70, 74],
            [70, 191, 189],
            [253, 180, 92],
            [148, 159, 177],
            [77, 83, 96]
        ];
        this.labels = [];
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.initFlag = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d');
        this.cvs = this.element.nativeElement;
        this.initFlag = true;
        this.taminLazyLoadService.loadJs(this.lib).toPromise().then((/**
         * @return {?}
         */
        () => {
            if (this.data || this.datasets) {
                this.refresh();
            }
        })).catch((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            //console.error(error);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.initFlag) {
            // Check if the changes are in the data or datasets
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes['data']) {
                    this.updateChartData(changes['data'].currentValue);
                }
                else {
                    this.updateChartData(changes['datasets'].currentValue);
                }
                this.chart.update();
            }
            else {
                // otherwise rebuild the chart
                this.refresh();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getChartBuilder(ctx /*, data:Array<any>, options:any*/) {
        /** @type {?} */
        const datasets = this.getDatasets();
        /** @type {?} */
        const options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hock for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} active
             * @return {?}
             */
            (active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                this.chartClick.emit({ event, active });
            });
        }
        /** @type {?} */
        const opts = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets: datasets
            },
            options: options
        };
        return new Chart(ctx, opts);
    }
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    updateChartData(newDataValues) {
        if (Array.isArray(newDataValues[0].data)) {
            this.chart.data.datasets.forEach((/**
             * @param {?} dataset
             * @param {?} i
             * @return {?}
             */
            (dataset, i) => {
                dataset.data = newDataValues[i].data;
                if (newDataValues[i].label) {
                    dataset.label = newDataValues[i].label;
                }
            }));
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getDatasets() {
        /** @type {?} */
        let datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (Array.isArray(this.data[0])) {
                datasets = ((/** @type {?} */ (this.data))).map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.labels[index] || `Label ${index}` };
                }));
            }
            else {
                datasets = [{ data: this.data, label: `Label 0` }];
            }
        }
        if (this.datasets && this.datasets.length ||
            (datasets && datasets.length)) {
            datasets = (this.datasets || datasets)
                .map((/**
             * @param {?} elm
             * @param {?} index
             * @return {?}
             */
            (elm, index) => {
                /** @type {?} */
                const newElm = Object.assign({}, elm);
                if (this.colors && this.colors.length) {
                    Object.assign(newElm, this.colors[index]);
                }
                else {
                    Object.assign(newElm, this.getColors(this.chartType, index, newElm.data.length));
                }
                return newElm;
            }));
        }
        if (!datasets) {
            throw new Error(`ng-charts configuration error, data or datasets field are required to render char ${this.chartType}`);
        }
        return datasets;
    }
    /**
     * @private
     * @return {?}
     */
    refresh() {
        this.chart = this.getChartBuilder(this.ctx);
    }
    /**
     * @private
     * @param {?} colour
     * @param {?} alpha
     * @return {?}
     */
    rgba(colour, alpha) {
        return 'rgba(' + colour.concat(alpha).join(',') + ')';
    }
    /**
     * @private
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    /**
     * @private
     * @param {?} colors
     * @return {?}
     */
    formatLineColor(colors) {
        return {
            backgroundColor: this.rgba(colors, 0.4),
            borderColor: this.rgba(colors, 1),
            pointBackgroundColor: this.rgba(colors, 1),
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: this.rgba(colors, 0.8)
        };
    }
    /**
     * @private
     * @param {?} colors
     * @return {?}
     */
    formatBarColor(colors) {
        return {
            backgroundColor: this.rgba(colors, 0.6),
            borderColor: this.rgba(colors, 1),
            hoverBackgroundColor: this.rgba(colors, 0.8),
            hoverBorderColor: this.rgba(colors, 1)
        };
    }
    /**
     * @private
     * @param {?} colors
     * @return {?}
     */
    formatPieColors(colors) {
        return {
            backgroundColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 0.6))),
            borderColor: colors.map((/**
             * @return {?}
             */
            () => '#fff')),
            pointBackgroundColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 1))),
            pointBorderColor: colors.map((/**
             * @return {?}
             */
            () => '#fff')),
            pointHoverBackgroundColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 1))),
            pointHoverBorderColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 1)))
        };
    }
    /**
     * @private
     * @param {?} colors
     * @return {?}
     */
    formatPolarAreaColors(colors) {
        return {
            backgroundColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 0.6))),
            borderColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 1))),
            hoverBackgroundColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 0.8))),
            hoverBorderColor: colors.map((/**
             * @param {?} color
             * @return {?}
             */
            (color) => this.rgba(color, 1)))
        };
    }
    /**
     * @private
     * @return {?}
     */
    getRandomColor() {
        return [this.getRandomInt(0, 255), this.getRandomInt(0, 255), this.getRandomInt(0, 255)];
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    generateColor(index) {
        return this.defaultColors[index] || this.getRandomColor();
    }
    /**
     * @private
     * @param {?} count
     * @return {?}
     */
    generateColors(count) {
        /** @type {?} */
        const colorsArr = new Array(count);
        for (let i = 0; i < count; i++) {
            colorsArr[i] = this.defaultColors[i] || this.getRandomColor();
        }
        return colorsArr;
    }
    /**
     * @private
     * @param {?} chartType
     * @param {?} index
     * @param {?} count
     * @return {?}
     */
    getColors(chartType, index, count) {
        if (chartType === 'pie' || chartType === 'doughnut') {
            return this.formatPieColors(this.generateColors(count));
        }
        if (chartType === 'polarArea') {
            return this.formatPolarAreaColors(this.generateColors(count));
        }
        if (chartType === 'line' || chartType === 'radar') {
            return this.formatLineColor(this.generateColor(index));
        }
        if (chartType === 'bar' || chartType === 'horizontalBar') {
            return this.formatBarColor(this.generateColor(index));
        }
        return (/** @type {?} */ (this.generateColor(index)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    windowResizeHandler(event) {
        //this.refresh(); Makes some problems on hover.
    }
}
TaminChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'tamin-chart',
                template: "<div style=\"display: block\">\r\n  <canvas #element></canvas>\r\n</div>\r\n",
                styles: [""]
            }] }
];
/** @nocollapse */
TaminChartComponent.ctorParameters = () => [
    { type: TaminLazyLoadService }
];
TaminChartComponent.propDecorators = {
    data: [{ type: Input }],
    datasets: [{ type: Input }],
    labels: [{ type: Input }],
    options: [{ type: Input }],
    chartType: [{ type: Input }],
    colors: [{ type: Input }],
    lib: [{ type: Input }],
    legend: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }],
    element: [{ type: ViewChild, args: ['element',] }],
    windowResizeHandler: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    TaminChartComponent.prototype.defaultColors;
    /** @type {?} */
    TaminChartComponent.prototype.data;
    /** @type {?} */
    TaminChartComponent.prototype.datasets;
    /** @type {?} */
    TaminChartComponent.prototype.labels;
    /** @type {?} */
    TaminChartComponent.prototype.options;
    /** @type {?} */
    TaminChartComponent.prototype.chartType;
    /** @type {?} */
    TaminChartComponent.prototype.colors;
    /** @type {?} */
    TaminChartComponent.prototype.lib;
    /** @type {?} */
    TaminChartComponent.prototype.legend;
    /** @type {?} */
    TaminChartComponent.prototype.chartClick;
    /** @type {?} */
    TaminChartComponent.prototype.chartHover;
    /** @type {?} */
    TaminChartComponent.prototype.element;
    /** @type {?} */
    TaminChartComponent.prototype.ctx;
    /** @type {?} */
    TaminChartComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    TaminChartComponent.prototype.cvs;
    /**
     * @type {?}
     * @private
     */
    TaminChartComponent.prototype.initFlag;
    /**
     * @type {?}
     * @private
     */
    TaminChartComponent.prototype.taminLazyLoadService;
}
/**
 * @record
 */
export function Color() { }
if (false) {
    /** @type {?|undefined} */
    Color.prototype.backgroundColor;
    /** @type {?|undefined} */
    Color.prototype.borderWidth;
    /** @type {?|undefined} */
    Color.prototype.borderColor;
    /** @type {?|undefined} */
    Color.prototype.borderCapStyle;
    /** @type {?|undefined} */
    Color.prototype.borderDash;
    /** @type {?|undefined} */
    Color.prototype.borderDashOffset;
    /** @type {?|undefined} */
    Color.prototype.borderJoinStyle;
    /** @type {?|undefined} */
    Color.prototype.pointBorderColor;
    /** @type {?|undefined} */
    Color.prototype.pointBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.pointBorderWidth;
    /** @type {?|undefined} */
    Color.prototype.pointRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHoverRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHitRadius;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBorderColor;
    /** @type {?|undefined} */
    Color.prototype.pointHoverBorderWidth;
    /** @type {?|undefined} */
    Color.prototype.pointStyle;
    /** @type {?|undefined} */
    Color.prototype.hoverBackgroundColor;
    /** @type {?|undefined} */
    Color.prototype.hoverBorderColor;
    /** @type {?|undefined} */
    Color.prototype.hoverBorderWidth;
}
/**
 * @record
 */
export function Colors() { }
if (false) {
    /** @type {?|undefined} */
    Colors.prototype.data;
    /** @type {?|undefined} */
    Colors.prototype.label;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFtaW4tY2hhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdGFtaW4tZnJhbWV3b3JrLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvdGFtaW4tY2hhcnQvdGFtaW4tY2hhcnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFnQyxNQUFNLEVBQWlCLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6SSxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSx3REFBd0QsQ0FBQztBQUM1RixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBUzdDLE1BQU0sT0FBTyxtQkFBbUI7Ozs7SUFpQzlCLFlBQTJCLG9CQUEwQztRQUExQyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBaENyRSxrQkFBYSxHQUFvQjtZQUMvQixDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDO1lBQ2QsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztZQUNkLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUM7WUFDZCxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO1lBQ2YsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztZQUNkLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7WUFDZixDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO1lBQ2YsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUNiLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7WUFDZCxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDO1lBQ2QsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztZQUNmLENB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QyxzQ0FBMEM7O0lBQzFDLHNDQUEwQzs7SUFDMUMsMkJBQStCOztJQUUvQixxQ0FBeUM7O0lBQ3pDLGlDQUFxQzs7SUFDckMsaUNBQTBCOzs7OztBQUc1Qiw0QkFHQzs7O0lBRkMsc0JBQWdCOztJQUNoQix1QkFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1RhbWluTGF6eUxvYWRTZXJ2aWNlfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90YW1pbi1sYXp5LWxvYWQvdGFtaW4tbGF6eS1sb2FkLnNlcnZpY2UnO1xuaW1wb3J0IHsgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmRlY2xhcmUgbGV0IENoYXJ0OiBhbnk7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3RhbWluLWNoYXJ0JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3RhbWluLWNoYXJ0LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vdGFtaW4tY2hhcnQuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBUYW1pbkNoYXJ0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIGRlZmF1bHRDb2xvcnM6IEFycmF5PG51bWJlcltdPiA9IFtcbiAgICBbMjU1LCA5OSwgMTMyXSxcbiAgICBbNTQsIDE2MiwgMjM1XSxcbiAgICBbMjU1LCAyMDYsIDg2XSxcbiAgICBbMjMxLCAyMzMsIDIzN10sXG4gICAgWzc1LCAxOTIsIDE5Ml0sXG4gICAgWzE1MSwgMTg3LCAyMDVdLFxuICAgIFsyMjAsIDIyMCwgMjIwXSxcbiAgICBbMjQ3LCA3MCwgNzRdLFxuICAgIFs3MCwgMTkxLCAxODldLFxuICAgIFsyNTMsIDE4MCwgOTJdLFxuICAgIFsxNDgsIDE1OSwgMTc3XSxcbiAgICBbNzcsIDgzLCA5Nl1cbiAgXTtcblxuICBASW5wdXQoKSBwdWJsaWMgZGF0YTogbnVtYmVyW10gfCBhbnlbXTtcbiAgQElucHV0KCkgcHVibGljIGRhdGFzZXRzOiBhbnlbXTtcbiAgQElucHV0KCkgcHVibGljIGxhYmVsczogQXJyYXk8YW55PiA9IFtdO1xuICBASW5wdXQoKSBwdWJsaWMgb3B0aW9uczogYW55ID0ge307XG4gIEBJbnB1dCgpIHB1YmxpYyBjaGFydFR5cGU6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIGNvbG9yczogQXJyYXk8YW55PjtcbiAgQElucHV0KCkgcHVibGljIGxpYjogc3RyaW5nO1xuICBASW5wdXQoKSBwdWJsaWMgbGVnZW5kOiBib29sZWFuO1xuICBAT3V0cHV0KCkgcHVibGljIGNoYXJ0Q2xpY2s6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCkgcHVibGljIGNoYXJ0SG92ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAVmlld0NoaWxkKCdlbGVtZW50JykgZWxlbWVudDogRWxlbWVudFJlZjtcblxuICBwdWJsaWMgY3R4OiBhbnk7XG4gIHB1YmxpYyBjaGFydDogYW55O1xuICBwcml2YXRlIGN2czogYW55O1xuICBwcml2YXRlIGluaXRGbGFnID0gZmFsc2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFtaW5MYXp5TG9hZFNlcnZpY2U6IFRhbWluTGF6eUxvYWRTZXJ2aWNlKSB7XG4gIH1cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3ZzID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5pbml0RmxhZyA9IHRydWU7XG4gICAgdGhpcy50YW1pbkxhenlMb2FkU2VydmljZS5sb2FkSnModGhpcy5saWIpLnRvUHJvbWlzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGF0YSB8fCB0aGlzLmRhdGFzZXRzKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIC8vY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmluaXRGbGFnKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgY2hhbmdlcyBhcmUgaW4gdGhlIGRhdGEgb3IgZGF0YXNldHNcbiAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdkYXRhJykgfHwgY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZGF0YXNldHMnKSkge1xuICAgICAgICBpZiAoY2hhbmdlc1snZGF0YSddKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDaGFydERhdGEoY2hhbmdlc1snZGF0YSddLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDaGFydERhdGEoY2hhbmdlc1snZGF0YXNldHMnXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSByZWJ1aWxkIHRoZSBjaGFydFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jaGFydCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2hhcnRCdWlsZGVyKGN0eDogYW55LyosIGRhdGE6QXJyYXk8YW55Piwgb3B0aW9uczphbnkqLyk6IGFueSB7XG4gICAgY29uc3QgZGF0YXNldHM6IGFueSA9IHRoaXMuZ2V0RGF0YXNldHMoKTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IGFueSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKHRoaXMubGVnZW5kID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy5sZWdlbmQgPSB7ZGlzcGxheTogZmFsc2V9O1xuICAgIH1cbiAgICAvLyBob2NrIGZvciBvbkhvdmVyIGFuZCBvbkNsaWNrIGV2ZW50c1xuICAgIG9wdGlvbnMuaG92ZXIgPSBvcHRpb25zLmhvdmVyIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5ob3Zlci5vbkhvdmVyKSB7XG4gICAgICBvcHRpb25zLmhvdmVyLm9uSG92ZXIgPSAoYWN0aXZlOiBBcnJheTxhbnk+KSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgJiYgIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFydEhvdmVyLmVtaXQoe2FjdGl2ZX0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMub25DbGljaykge1xuICAgICAgb3B0aW9ucy5vbkNsaWNrID0gKGV2ZW50OiBhbnksIGFjdGl2ZTogQXJyYXk8YW55PikgPT4ge1xuICAgICAgICB0aGlzLmNoYXJ0Q2xpY2suZW1pdCh7ZXZlbnQsIGFjdGl2ZX0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsczogdGhpcy5sYWJlbHMsXG4gICAgICAgIGRhdGFzZXRzOiBkYXRhc2V0c1xuICAgICAgfSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBDaGFydChjdHgsIG9wdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDaGFydERhdGEobmV3RGF0YVZhbHVlczogbnVtYmVyW10gfCBhbnlbXSk6IHZvaWQge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5ld0RhdGFWYWx1ZXNbMF0uZGF0YSkpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0OiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBkYXRhc2V0LmRhdGEgPSBuZXdEYXRhVmFsdWVzW2ldLmRhdGE7XG5cbiAgICAgICAgaWYgKG5ld0RhdGFWYWx1ZXNbaV0ubGFiZWwpIHtcbiAgICAgICAgICBkYXRhc2V0LmxhYmVsID0gbmV3RGF0YVZhbHVlc1tpXS5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhID0gbmV3RGF0YVZhbHVlcztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldERhdGFzZXRzKCk6IGFueSB7XG4gICAgbGV0IGRhdGFzZXRzOiBhbnkgPSB2b2lkIDA7XG4gICAgLy8gaW4gY2FzZSBpZiBkYXRhc2V0cyBpcyBub3QgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIHByZXNlbnRcbiAgICBpZiAoIXRoaXMuZGF0YXNldHMgfHwgIXRoaXMuZGF0YXNldHMubGVuZ3RoICYmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YVswXSkpIHtcbiAgICAgICAgZGF0YXNldHMgPSAodGhpcy5kYXRhIGFzIEFycmF5PG51bWJlcltdPikubWFwKChkYXRhOiBudW1iZXJbXSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiB7ZGF0YSwgbGFiZWw6IHRoaXMubGFiZWxzW2luZGV4XSB8fCBgTGFiZWwgJHtpbmRleH1gfTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0cyA9IFt7ZGF0YTogdGhpcy5kYXRhLCBsYWJlbDogYExhYmVsIDBgfV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YXNldHMgJiYgdGhpcy5kYXRhc2V0cy5sZW5ndGggfHxcbiAgICAgIChkYXRhc2V0cyAmJiBkYXRhc2V0cy5sZW5ndGgpKSB7XG4gICAgICBkYXRhc2V0cyA9ICh0aGlzLmRhdGFzZXRzIHx8IGRhdGFzZXRzKVxuICAgICAgICAubWFwKChlbG06IG51bWJlciwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0VsbTogYW55ID0gT2JqZWN0LmFzc2lnbih7fSwgZWxtKTtcbiAgICAgICAgICBpZiAodGhpcy5jb2xvcnMgJiYgdGhpcy5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VsbSwgdGhpcy5jb2xvcnNbaW5kZXhdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbG0sIHRoaXMuZ2V0Q29sb3JzKHRoaXMuY2hhcnRUeXBlLCBpbmRleCwgbmV3RWxtLmRhdGEubGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdFbG07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGF0YXNldHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmctY2hhcnRzIGNvbmZpZ3VyYXRpb24gZXJyb3IsIGRhdGEgb3IgZGF0YXNldHMgZmllbGQgYXJlIHJlcXVpcmVkIHRvIHJlbmRlciBjaGFyICR7dGhpcy5jaGFydFR5cGV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXRzO1xuICB9XG5cbiAgcHJpdmF0ZSByZWZyZXNoKCk6IGFueSB7XG4gICAgdGhpcy5jaGFydCA9IHRoaXMuZ2V0Q2hhcnRCdWlsZGVyKHRoaXMuY3R4KTtcbiAgfVxuXG4gIHByaXZhdGUgcmdiYShjb2xvdXI6IEFycmF5PG51bWJlcj4sIGFscGhhOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiAncmdiYSgnICsgY29sb3VyLmNvbmNhdChhbHBoYSkuam9pbignLCcpICsgJyknO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21JbnQobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0TGluZUNvbG9yKGNvbG9yczogQXJyYXk8bnVtYmVyPik6IENvbG9yIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLnJnYmEoY29sb3JzLCAwLjQpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMucmdiYShjb2xvcnMsIDEpLFxuICAgICAgcG9pbnRCYWNrZ3JvdW5kQ29sb3I6IHRoaXMucmdiYShjb2xvcnMsIDEpLFxuICAgICAgcG9pbnRCb3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgcG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgcG9pbnRIb3ZlckJvcmRlckNvbG9yOiB0aGlzLnJnYmEoY29sb3JzLCAwLjgpXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0QmFyQ29sb3IoY29sb3JzOiBBcnJheTxudW1iZXI+KTogQ29sb3Ige1xuICAgIHJldHVybiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMucmdiYShjb2xvcnMsIDAuNiksXG4gICAgICBib3JkZXJDb2xvcjogdGhpcy5yZ2JhKGNvbG9ycywgMSksXG4gICAgICBob3ZlckJhY2tncm91bmRDb2xvcjogdGhpcy5yZ2JhKGNvbG9ycywgMC44KSxcbiAgICAgIGhvdmVyQm9yZGVyQ29sb3I6IHRoaXMucmdiYShjb2xvcnMsIDEpXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UGllQ29sb3JzKGNvbG9yczogQXJyYXk8bnVtYmVyW10+KTogQ29sb3JzIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMubWFwKChjb2xvcjogbnVtYmVyW10pID0+IHRoaXMucmdiYShjb2xvciwgMC42KSksXG4gICAgICBib3JkZXJDb2xvcjogY29sb3JzLm1hcCgoKSA9PiAnI2ZmZicpLFxuICAgICAgcG9pbnRCYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5tYXAoKGNvbG9yOiBudW1iZXJbXSkgPT4gdGhpcy5yZ2JhKGNvbG9yLCAxKSksXG4gICAgICBwb2ludEJvcmRlckNvbG9yOiBjb2xvcnMubWFwKCgpID0+ICcjZmZmJyksXG4gICAgICBwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yOiBjb2xvcnMubWFwKChjb2xvcjogbnVtYmVyW10pID0+IHRoaXMucmdiYShjb2xvciwgMSkpLFxuICAgICAgcG9pbnRIb3ZlckJvcmRlckNvbG9yOiBjb2xvcnMubWFwKChjb2xvcjogbnVtYmVyW10pID0+IHRoaXMucmdiYShjb2xvciwgMSkpXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UG9sYXJBcmVhQ29sb3JzKGNvbG9yczogQXJyYXk8bnVtYmVyW10+KTogQ29sb3Ige1xuICAgIHJldHVybiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5tYXAoKGNvbG9yOiBudW1iZXJbXSkgPT4gdGhpcy5yZ2JhKGNvbG9yLCAwLjYpKSxcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvcnMubWFwKChjb2xvcjogbnVtYmVyW10pID0+IHRoaXMucmdiYShjb2xvciwgMSkpLFxuICAgICAgaG92ZXJCYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5tYXAoKGNvbG9yOiBudW1iZXJbXSkgPT4gdGhpcy5yZ2JhKGNvbG9yLCAwLjgpKSxcbiAgICAgIGhvdmVyQm9yZGVyQ29sb3I6IGNvbG9ycy5tYXAoKGNvbG9yOiBudW1iZXJbXSkgPT4gdGhpcy5yZ2JhKGNvbG9yLCAxKSlcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21Db2xvcigpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFt0aGlzLmdldFJhbmRvbUludCgwLCAyNTUpLCB0aGlzLmdldFJhbmRvbUludCgwLCAyNTUpLCB0aGlzLmdldFJhbmRvbUludCgwLCAyNTUpXTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDb2xvcihpbmRleDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRDb2xvcnNbaW5kZXhdIHx8IHRoaXMuZ2V0UmFuZG9tQ29sb3IoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDb2xvcnMoY291bnQ6IG51bWJlcik6IEFycmF5PG51bWJlcltdPiB7XG4gICAgY29uc3QgY29sb3JzQXJyOiBBcnJheTxudW1iZXJbXT4gPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29sb3JzQXJyW2ldID0gdGhpcy5kZWZhdWx0Q29sb3JzW2ldIHx8IHRoaXMuZ2V0UmFuZG9tQ29sb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yc0FycjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q29sb3JzKGNoYXJ0VHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogQ29sb3Ige1xuICAgIGlmIChjaGFydFR5cGUgPT09ICdwaWUnIHx8IGNoYXJ0VHlwZSA9PT0gJ2RvdWdobnV0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGllQ29sb3JzKHRoaXMuZ2VuZXJhdGVDb2xvcnMoY291bnQpKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnRUeXBlID09PSAncG9sYXJBcmVhJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UG9sYXJBcmVhQ29sb3JzKHRoaXMuZ2VuZXJhdGVDb2xvcnMoY291bnQpKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnRUeXBlID09PSAnbGluZScgfHwgY2hhcnRUeXBlID09PSAncmFkYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRMaW5lQ29sb3IodGhpcy5nZW5lcmF0ZUNvbG9yKGluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2JhcicgfHwgY2hhcnRUeXBlID09PSAnaG9yaXpvbnRhbEJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdEJhckNvbG9yKHRoaXMuZ2VuZXJhdGVDb2xvcihpbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNvbG9yKGluZGV4KSBhcyBDb2xvcjtcbiAgfVxuXG5cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pXG4gIHdpbmRvd1Jlc2l6ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAvL3RoaXMucmVmcmVzaCgpOyBNYWtlcyBzb21lIHByb2JsZW1zIG9uIGhvdmVyLlxuICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvciB7XG4gIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBib3JkZXJXaWR0aD86IG51bWJlciB8IG51bWJlcltdO1xuICBib3JkZXJDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBib3JkZXJDYXBTdHlsZT86IHN0cmluZztcbiAgYm9yZGVyRGFzaD86IG51bWJlcltdO1xuICBib3JkZXJEYXNoT2Zmc2V0PzogbnVtYmVyO1xuICBib3JkZXJKb2luU3R5bGU/OiBzdHJpbmc7XG5cbiAgcG9pbnRCb3JkZXJDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBwb2ludEJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBwb2ludEJvcmRlcldpZHRoPzogbnVtYmVyIHwgbnVtYmVyW107XG5cbiAgcG9pbnRSYWRpdXM/OiBudW1iZXIgfCBudW1iZXJbXTtcbiAgcG9pbnRIb3ZlclJhZGl1cz86IG51bWJlciB8IG51bWJlcltdO1xuICBwb2ludEhpdFJhZGl1cz86IG51bWJlciB8IG51bWJlcltdO1xuXG4gIHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgcG9pbnRIb3ZlckJvcmRlckNvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIHBvaW50SG92ZXJCb3JkZXJXaWR0aD86IG51bWJlciB8IG51bWJlcltdO1xuICBwb2ludFN0eWxlPzogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgaG92ZXJCYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgaG92ZXJCb3JkZXJDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBob3ZlckJvcmRlcldpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9ycyBleHRlbmRzIENvbG9yIHtcbiAgZGF0YT86IG51bWJlcltdO1xuICBsYWJlbD86IHN0cmluZztcbn1cblxuXG5cbiJdfQ==